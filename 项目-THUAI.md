# THUAI

## 总体情况

基于何吉轩（前任技术部部长、现任副主席）的交接文档与更多信息整理：

### 游戏内容

核心是要让选手做一个代码填空，补充智能体的行动逻辑。游戏可以是回合制游戏，也可以是实时的。去年的仓库：https://github.com/THUAI-Team

因此我们要做的有三件事：

1. 开发游戏后端逻辑
2. 开发前端显示界面
3. 留出玩家可以填空的函数

后端逻辑使用C/C++。

前端显示可以用**Unity**，可以用**Cocos**。如果想用Unity，可以联系一下赛事部的同学，他们会给一些参考。

### 部署平台

今年我估计大概率是用去年图谋的对战平台Botany，**具体程序如何和平台对接，记得开发的时候把周恒宇学长也叫上，去年是他负责对接的**。

### DDL

需要在校科展上决出决赛的名次——校科展通常在校庆期间举办——今年的校庆日是4月30日（4月最后一个周日）。

决赛前还需要几周时间的初赛等等，故需要倒推一个月，==最晚四月初得开始初赛==（可以安排三周时间初赛）。

## 游戏构思

### 核心构思

- 仿「使命召唤」FPS游戏的「大战场」枪战模式。
  - 两队对决，每个队伍有多名玩家。
  
  - 地图随机生成，出生点随机。分为「路面方块」与「障碍物方块」。
  
    > 地图大小还没确定，初步比划了下32*32是个可选项。
  
    > 对地图的期待：
    >
    > - 必须连通。
    >
    > - [ ] 希望能有一些固定的经典结构，如能允许“秦王绕柱走”，不要总像迷宫一样。但倒也无所谓。
    >
    >   相关：Roguelike游戏。
    >
    >   地图生成算法可以抄现成的Roguelike游戏的算法。常见的核心思路有 随机游走、元胞自动机、随机生成障碍物再判断连通性。
    >
    >   * [迷宫&房间类](https://zhuanlan.zhihu.com/p/30724817)
    >   * [洞穴类](http://roguebasin.com/index.php/Category:WorldGeneration)
  
  - 死亡后等待一小段时间即可复活。复活点不会在敌人的视线范围内，在此限制下复活于地图上的随机位置。
  
  - 给定一段时间，时间到后比较双方累计击杀数，多者胜。
  
- 空间穿梭。
  - 可通过绘制线段来绘制传送阵。传送阵的判定范围：电子表的「8」。即传送阵由上下两个方块构成。

    > 显然传送阵方块必须为路面方块。不然会传送到障碍物内部的。
    
    > 边长为1的正方形太简单，边长为2的正方形太复杂。8字形相对适中，且构成的图形很容易命名（如数字7）。
    
    > 以「下方方块」的坐标 来标记整个传送阵的坐标。
    
  - 「每种」传送阵的第一个实例成为「主传送阵」，后续的实例称「附属传送阵」。

  - 感知与操作传送阵线段无需视野，但要求距离足够近。

    - 感知距离 >> 操作距离

      > 范围的形状采用简单的正方形□形状，以便处理。

    - 靠近传送阵时，可激活使用传送阵：

      1. 瞬移到所激活的传送阵。
      2. 前摇时间。
      3. 传送到相应主传送阵（下方方块的中心位置）。
      4. 后摇时间。

      > 前后摇时间作用于「使用者」而非传送阵。即人物在此期间将无法「移动」与「操作传送阵」（仍可转向、射击），但不影响其他人使用传送阵。这样易于实现。

      > 考虑后认为不需要设置冷却时间。

    - 可通过继续添加或擦除线段来破坏传送阵。若主传送阵被破坏，则同图形的附属传送阵中最老的那个自动成为该图形的新的主传送阵。

    - - [ ] 开局时是否要先随机生成一些传送阵线段？

- - [ ] 脱战后血量逐渐恢复至满——没想好到底要不要这个设定。

- 单份代码控制多个AI。每个队伍的多名AI由同一份代码「分别」操控。不能直接共享信息——即在不同AI之间传递信息的唯一方式是通过约定好的游戏操作

  - - [ ] 不确定是否要让AI知道队伍内其他AI的当前位置。

### 必然推理

- 方向与视野。只能看到前方一定夹角内的事物。
  - 转向必须有速度限制，不然所有人都会旋转着走路。如10度一单位，一帧只允许转一单位或不转。
  
  - 枪口锁定正前方。允许半个转向单位的误差。
  
    > 具体实现时可能要替换成子弹具有大小之类的；总之差不多就可以。
  
  - 移动方向允许在{前, 后, 不移}×{左, 右, 不移}中选择。但左/右/后的速度会比前慢。

### 相关推导（按个人认为需考虑的优先级降序排列）

- 为简化制作，可将人物抽象为几何图形，在带障碍的二维平面内运动。由于有方向，抽象为箭头最合适；但简便起见，逻辑上仍仅将箭头的顶端一点作为人物的坐标。射击时在画面上显示出弹道。
  - 可用颜色表示状态，让观众看起来更舒服。如 用红色表示位置完全暴露 或者 用红色表示濒死。
  - 游戏窗口上方显示击杀实况，右边显示当前KD、主传送阵、乃至持续中的连杀技能等情况。
  
- 射击改成「开始射击」与「停止射击」。这样就能很方便地加入反应速度——开始射击与停止射击的指令下达后需要一段时间才能生效（改变射击状态）。

- 枪声、脚步声。有多种合理组合，选一种就好：真实感，枪声完全暴露位置，快走的脚步声对附近人物暴露大致方向（前/后方），慢走的脚步声忽略；仿黑暗森林，枪静音，快走暴露，慢走忽略；只考虑枪声，忽略脚步声……——若对快慢走的脚步声有区分的话，最好要提供「慢速前进」（速度与左/右/后一致）的选项。
  
  - 我偏好「枪声完全暴露」+「脚步声对附近人物暴露大致方向（前/后方）」，但不区分快走或慢走的脚步声。
  
- 每条命都有1个手雷。前摇后沿正方向滑出并定时爆炸，爆炸伤害无视障碍物。

  > 防止「蹲角落不动」成为「易实现」但「极难破解」、而且「变数太少」的战术。

- 连杀奖励。初步考虑觉得「连杀技能」就够了，「属性加点」等不够直观且过于复杂。如「无人侦查机」（定期扫描全图，告知敌方此刻位置）（COD中，约2.2秒扫描一次，算上初始次约能提供11次扫描）、「反侦察机」（使敌方雷达失效）、「侦察卫星」（实时告知敌方位置与朝向，或者所有信息）、「炸弹之母」（击杀敌方所有玩家）。
  
  - 使用技能时，游戏暂停，图标与文本从右侧飞到中部，再从左侧飞出去。
  
  > 也许可以使比赛更精彩，但重要性比上面几个要低不少——在合理性、平衡性上都没什么新贡献。

---

倾向于淘汰的构思：

- 枪械类型。霰弹枪（近距离超高伤害、中距离伤害很低、远距离无伤害、攻击间隔中等）、步枪（近/中伤害中等、远距离伤害低、攻击间隔小）、狙击枪（秒杀伤害、射击前必须开镜且静止、开镜收镜需要一定时间、开镜时移动速度与视野夹角大减、攻击间隔大、移动速度慢）。UI上，主要需在人物附近显示一个小图标或小文字（霰/步/狙）以表示当前枪种；因为真实地展现枪的话，人物也必须真实了，基本就得用3D画面了，感觉工作量飙升。

  > 太麻烦了。

## 提供给选手

### 接口

#### 数据类型

* 坐标：
  * 绝对坐标：直角坐标系，以左下角为原点，横轴（x轴）以右为正方向，纵轴（y轴）以上为正方向。
  * 相对于人物坐标：极坐标系，以人物为原点，以正前方为极轴方向，左右方向分开表示（因此角度数值均为正值），角度单位为「度」。
* 方向：
  * 相对于整张地图的方向：用角度值表示。以逆时针为正方向，使用角度制，取值范围为 $[0,360°)$。
  * 相对于人物的方向：`LEFT`、`RIGHT`、`FRONT`、`BACK`
  * 传送阵图形中各线段的方向（顺序为汉字 `日` 的笔顺）：`LEFTUP`、`LEFTDOWN`、`UP`、`RIGHTUP`、`RIGHTDOWN`、`CENTER`、`DOWN`。
* 传送阵图形：
  * 用7位二进制数编码，0表示空白、1表示已绘制。可与表示线段方向的枚举值 `LEFTUP`、`LEFTDOWN` 等「按位与」得到指定方向的线段状态。
* 转向的单位角度：10度。提供此常量。

---

示例：

```c++
// 未触及游戏逻辑

// 较底层的游戏逻辑
struct Coordinate {
    double x;
    double y;
}
struct PolarCoordinate {
    LeftOrRight dir;
    AngleInDegree angle;
    double distance;
}
typedef char PortalPattern;

// 较顶层的游戏逻辑
struct PlayerState {
    bool is_shooting;
    bool is_using_portal;
    bool can_move;
}

struct Self {
    int id;
    Coordinate pos;
    AngleInDegree orien;
    PlayerState state;
    Hp hp;
}
struct Player {
    Team team;
    int id;
    Coordinate pos;
    AngleInDegree orien;
    PlayerState state;
}
struct LineSegment {
    Coordinate pos;
    HorizontalOrVertical dir;
}
struct Portal {
    Coordinate pos;
    PortalPattern pattern;
    bool is_main;
    bool is_being_used;
}
```

#### 信息

* 己方阵营。
* 全场地图。仅标识了障碍物状况，不含人物、传送阵等信息。
* 赛况：当前比分、剩余时间。
* 自身信息。如位置、面朝方向、血量、射击状态。
* 感知到的其他人物。
  * 视觉
  * 枪声
  * 脚步声
  * 侦察机
* 感知到的传送阵线段。
* 感知到的传送阵。基于「感知到的传送阵线段」推理得。

> 坐标只提供直角坐标，不直接提供极坐标。若需要，可使用下面提供的函数转化得到。

#### 信息处理

* 坐标系。

  函数：输入直角坐标，输出极坐标。

  函数：输入相对于人物的极坐标，输出直角坐标。

* 人物方向。

  函数：输入直角坐标或相对于人物的极坐标，输出要转向该坐标的话应当左移还是右移。

* 判断某坐标是否在 修改/使用 传送阵的范围内。

#### 操作

* 移动。
* 转向。左转、右转。
* 射击。开始射击、停止射击。
* 修改传送阵的线段。绘制、擦除、反转。
* 使用传送阵。

### 示例AI

相对无脑一些，但要使用到大部分基本的API。

* 没看到敌人就无脑前进（前方是障碍物就左转），看到敌人就原地瞄准射击。
* 无脑持续开枪以暴露自身位置，即使没看到敌人。
* 每隔一段时间就操作传送阵，随机无脑版。

## 项目管理

GitHub 仓库：

工作流：从主分支切出新分支→修改→发PR并入主分支。

编码规范：

* C++命名规范
  * 文件名，全小写、下划线。如 `my_class.cpp`。
  * 类型，大驼峰。如 `MyClass`、`Html`。
  * 宏、常量，全大写、下划线。如 `MY_CONSTANT`。
  * 变量，全小写、下划线。如 `my_variable`。
    * 全局变量，前缀 `g_`。如 `g_system_time`。
    * 单例变量，前缀 `a_`。如 `a_timer`。
    * 函数指针除外，像函数那样命名。
  * 函数。
    * 普通函数，大驼峰。如 `IsAlreadyProcessed(element)`。
    * 短小的内联函数（即使在循环中调用也无需缓存其返回值），小写命名可以接受，类似于当变量用。如 `sin(x)`。
    * 存取函数，与对应变量匹配。如对于 `int` 变量 `count`，其取值函数为 `count() `，设值函数为 `set_count(int count)`。这样有助于和其他函数区分开，且获取成员值的写法与直接访问类似。
  * 与现有实体相似，则模仿之。

## 模块划分与分工



## 前后端接口设计



## 项目进度计划

